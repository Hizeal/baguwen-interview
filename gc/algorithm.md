# GC 算法
分析：算法可以从多个维度进行分析。

## 总览

### 触发条件

- 主动触发(手动触发)，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。

- 被动触发，分为两种方式：

    - 使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。

    - 使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量 GOGC）：默认 100%，即当内存扩大一倍时启用 GC。

### 收集器与回收器

首先，算法可以分成两个大问题
1. 如何找到存活对象：基本上就是两类，引用计数和标记（也叫做跟踪式，可达性分析）；
2. 怎么回收空间：复制，整理或者清扫。复制是指直接将存活对象拷贝到另外一块内存区域；压缩是指，将存活对象挪到一起；清扫实际上，大多数时候，就是做一些标记，标记内存可用；

这里要强调一下清扫。清扫明面上是指，我将垃圾扫掉，实际上是指将内存返回给内存分配器。那么问题就来了，内存分配器怎么维护这些空闲内存？基本上这里又是两种选择，一种是位图，一种是空闲链表法。相比之下，采用复制的算法，基本上就只需要维护寥寥几个地址。

如果笛卡尔积一下，就有了：
1. 引用计数-复制，引用计数-整理，引用计数-清扫；
2. 标记-复制，标记-整理，标记-清扫；

不过引用计数我们面试比较少遇到，它在实际中用得也不多，标记类用得比较多。

### 并发与并行

算法又有并发和并行之分。这里提到的并发和并行，在GC这个特定的语义下，含义稍微有点区别。

这里我们说的并发，其实是指 GC 线程和应用线程，一起运行。就是一边GC，一边对外服务。并行则是指多个GC线程一起干活。

那么，要记住，多核 CPU 之下，并发往往意味着并行。即，GC 线程和应用线程是并行的，GC线程和GC线程也是并行的，应用线程和应用线程也是并行的。

但是并行不一定意味着并发。例如 Java 里面的 Parallel New，就是GC线程并行收集，这个就不是并发的，因为没有应用线程此时也在运转。

典型的并发 GC：
1. Java 上 HotSpot 实现的 CMS，G1，ZGC
2. Golang GC；

典型的并行 GC：HotSpot 带 Parallel 关键字的，Old Parallel, Parallel New 

#### 类似问题
- 并发 GC 是并行 GC吗？多核 CPU 上就是，否则就不是
- 并行 GC 一定是并发 GC吗？不是

### 分代

不是所有 GC 都有分代的！！

分代主要是基于分代假说，大部分刚分配的对象会在短时间内死掉，越是生存时间长的对象，越不容易死掉

（类比“**幼儿夭折**”和“**老不死**”）

![HotSpot分代的效果](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_003_alc_vs_srvng.png)

典型的分代 GC：HotSpot 的大部分GC都是

### 增量回收

增量回收核心在于，回收的时候并不是将整个堆，或者整个分代回收掉，而是只回收部分。实施增量回收核心就在于避免在一次GC中消耗太多资源，典型的就是 G1 采用了增量回收来避免停顿时间超长。

典型的增量回收GC：HotSpot G1

## 面试题

### 你了解 XXX 算法吗？

记住步骤：
1. 基本流程
2. 优缺点

下面我们一个个算法说过去。

#### 标记-复制

（首先回答基本流程）标记-复制算法，在GC开始的时候，会从 GC root 出发标记，沿着对象的引用链，标记存活的对象。在标记完成之后，将存活的对象复制到另外一块内存。Java的Serial New, Parallel New 和 G1 都是采用了标记复制算法。

（讨论优缺点）该算法的优点是，复制会保证我们能够得到一块连续的内存，可以采用高效率的内存分配方案（叫做bump-the-pointer，其实就是指针移动）。缺点则是内存利用率不高，极端情况下，我们只能利用一半内存，另外一半内存要作为复制的目标内存。而且复制也是一个消耗极大的过程。

![指针碰撞](https://img-blog.csdnimg.cn/20201130155644621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JkX3dfY3Nkbg==,size_16,color_FFFFFF,t_70#pic_center)

##### 类似问题
- 复制算法，只能使用一半内存吗？这个问题是说，我们在使用复制算法的时候，要留出一部分空间来装复制的对象。比如说，我们有1G内存，复制算法是不是只能使用 500 M，剩下的500M作为装存活对象的空间。并不是，假如说我们存活对象占比10%，例如我100M对象，存活的有10M。那么我就只需要10M来装存活对象。回到这个 1G 的例子，这意味着我可以用 800 M,第一次回收，有 80M 存活，我丢到一个 100M 的块里边；第二次它是 （800+100） * 10% = 90 M 存活对象，还剩下 100 M，非常完美放下。这就是 JVM 里面为啥是两个 Survivor。因此用复制算法，内存利用率也可以超过50%。
![注意一个Eden两个](https://img-blog.csdn.net/20170518171044703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3RlZF96eHo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 标记-整理

（首先回答基本流程）标记-整理算法，在GC开始的时候，会从 GC root 出发标记，沿着对象的引用链，标记存活的对象。在标记完成之后，将存活的对象全部挪到一侧。这个过程类似于标记-复制。比较有名的采用了这个算法的就是 HotSpot 里面的 Serial Old 和 Parallel Old。

（讨论优缺点）该算法的优点是，整理复制会保证我们能够得到一块连续的内存，可以采用高效率的指针碰撞技术来分配内存。缺点则是整理过程非常耗时，涉及到了大量对象移动。比如 CMS 在启用压缩之后，这个过程是 STW 的，导致 GC 停顿时间特别长。

（讨论改进方案，亮点）有一种改进思路，是不进行全量整理，而是部分整理，即每次 GC 只会整理一部分，作为 GC 停顿时间和内存碎片的一种权衡。

#### 标记-清扫

（首先回答基本流程）标记-清扫算法，在GC开始的时候，会从 GC root 出发标记，沿着对象的引用链，标记存活的对象。在标记完成之后，垃圾回收器会把空闲内存交回内存分配器。最有名的标记清扫垃圾回收器是 CMS 回收器。

（讨论优缺点）该算法的优点是，清扫的过程比复制和整理要快很多。但是带来的缺点是，内存分配要更加复杂，并且空闲内存不再是一个连续的块。比如说 CMS 就采用了空闲链表来管理空闲内存（这里可能引导过去聊CMS 空闲内存管理，不熟悉就忽略）。带来严重的内存碎片问题。

##### 如何引导
- 从操作系统内存管理聊过来

#### 引用计数

引用计数是在对象里面维护一个计数，标记有多少对象使用到了该对象。如果计数为0，就表明该对象可以被回收了。

该算法的优点是实现简单，GC过程很快。缺点则是，循环引用难以解决。所谓的循环引用，是指多个对象之间互相引用，最终行成一个环，因此它们的计数永远都不会为0。Swift 的垃圾回收就是采用了引用计数（赫赫有名的ARC），还有很多智能指针也是用引用计数来实现的。

还有一个缺点，则是整个开销和引用变更次数成正比。

（注意，如果记得住，可以接着回答**如何解决循环引用**）

### 如何解决引用计数中的循环引用问题？
分析：难题。其实大多数情况下，面试官问出来这个问题，也没指望我们能回答出来，就是抱着万一你知道的心态。当然，如果你面的语言，就是用了引用计数来做GC的话，那么这会比较重要。对于 Java，golang 开发来说，稍微知道一点就可以。

答案：一般是有三种策略：
1. 采用特殊引用。例如使用 weak reference，弱引用。这一类的做法是用户需要自己显式管理自己的引用，在出现循环引用的地方，将一部分引用修改为 weak reference，从而所谓的 strong reference 就不再组成环；
2. 采用后备的追踪式收集器。一般来说，是把可能出现环的对象单独处理，用追踪式的收集器标记一遍，这些就是存活对象。（Python就是这种策略，不了解算法细节）
3. 采用试探删除策略。该方法类似于图里面去除环的算法，尝试把某些引用删掉。如果删掉之后别的对象的计数变为0，那么说明这些对象只有环内的引用，因此是可回收对象。

#### 如何引导
- 在聊到了引用计数的时候。这个是一个比较安全的亮点，就是认真研究过循环引用处理方案的面试官不多
- 在聊到特殊引用的时候，可以讲一下特殊引用在引用计数里面的应用。

#### 类似问题
- 追踪式垃圾回收器如何解决循环引用问题？这个问题其实是吓人的，因为追踪式的一般都是使用三色法来追踪对象，天然就解决了，可以参考后面的三色标记法面试题

### 引用计数和可达性分析的优缺点？
分析：根据两者的基本特征来回答就可以。这个问题比较罕见。

答案：引用计数最大的优点就是实现简单、GC 很快，整体开销被平摊到了整个应用生命周期内，对并发 GC 支持比较好。缺点则是循环引用难以解决，整体开销和引用变更次数成正比，比较大。

可达性分析则是会在 GC 过程中引入 STW，难以实现，并发 GC 的实现特别困难。优点则是可达性分析只和存活对象数量有关，开销较小。并且可达性分析解决循环引用的问题非常容易

#### 如何引导
- 无论是讨论了引用计数还是可达性分析，都可以做一个总结

#### 类似问题
- XXX 为什么用引用计数/可达性分析？总结它们的优缺点，指出就是不同人在不同场景下的权衡。


### 什么是三色标记法
分析：考察基本算法。答出一般步骤就可以。如果要刷亮点，就要回答并发标记流程，并发的情况下，可能误把回收对象标记为存活。

答案：三色标记法是指在标记过程中将对象标记为黑色、灰色或者白色。黑色代表存活对象，灰色代表正在标记中，白色表示死亡对象；
1. 最开始的时候，所有的对象都是白色的；
2. 而后从GC root 出发，首先将对象标记为灰色，其次将其引用对象标记为灰色，再把自己从灰色变为黑色；
3. 重复步骤2，直到灰色对象均为黑色
4. 通过写屏障检测对象有变化，重复以上操作
5. 收集所有白色对象

![三色标记法](https://pic2.zhimg.com/v2-5fe8ea45e2518ca19cfeb31558160fb1_b.webp)

（引出误标记的话题）这个标记过程可以和应用线程并发运行，不过这个时候可能存在一个问题，就是可能一个对象被标记为黑色（即存活），但是随后应用线程更新了指向它的引用，它变成了死对象。这个时候，标记结束之后，该对象依旧会被认为还存活着（活死人，假阴性）。

（这里我们补充一下如何解决循环引用）使用三色标记法能够天然解决循环引用的问题，因为循环引用的一端，必然会被先染成了黑色，这时候就直接跳过，而不会重复染色，导致循环。

#### 类似问题
- 三色标记法怎么解决循环引用问题？其实这个问题有点鸡肋，一般了解一点三色标记法的人都不会问这个。因为三色标记法里面，循环引用就不是一个问题。
- 标记为黑色的对象一定是存活对象吗？并发下就不是，非并发下就是

#### 补充：写屏障
为了避免 GC 的过程中新修改的引用关系到 GC 的结果发生错误，我们需要进行 STW）。但是 STW 会影响程序的性能，所以我们要通过写屏障技术尽可能地缩短 STW 的时间
- 引用对象丢失的条件：
  - 一个黑色的节点 A 新增了指向白色节点 C 的引用，并且白色节点 C 没有除了 A 之外的其他灰色节点的引用，或者存在但是在 GC 过程中被删除了。
    - 以上两个条件需要同时满足：
      - 满足条件 1 时说明节点 A 已扫描完毕，A 指向 C 的引用无法再被扫描到；
      - 满足条件 2 时说明白色节点 C 无其他灰色节点的引用了，即扫描结束后会被忽略 。

    - 破坏条件1：Dijistra 写屏障
      - 黑色节点不允许引用白色节点，一旦其新增了白色节点的引用时，将对应的白色节点改为灰色

    - 破坏条件2：Yuasa 写屏障
      - 黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用
      - 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色

### 补充：STW
为了避免在 GC 的过程中，对象之间的引用关系发生新的变更，使得 GC 的结果发生错误（如 GC 过程中新增了一个引用，但是由于未扫描到该引用导致将被引用的对象清除了），停止所有正在运行的协程。

### 为什么使用并发 GC？

分析：并发 GC 意味着应用线程不停，减少停顿时间。

答案：并发 GC 有很显著的优势，即在整个回收过程中，大部分情况下，应用依旧可以对外服务，仅仅需要在特定的时间节点上 STW，整体停顿时间很多。

不过并发 GC 一般实现复杂，而且吞吐量不如并行 GC。（这里尝试引导面试官，进一步问，为什么并发 GC 吞吐量不如并行 GC）

### 为什么并发 GC 的吞吐量一般比并行 GC 要低？

分析：考察并发 GC 实现上的难点。核心就在于并发 GC 要额外引入别的数据结构和步骤来处理，在并发过程中，引用的变更。例如回收过程中，应用创建了新的对象，修改了原本的对象。我们这里使用具体的例子来总结。

答案：主要在于，并发 GC需要引入额外的数据结构和步骤来处理并发过程中，应用线程修改过的对象。（如果自己不熟悉后面的这些，就不要说）例如在 Java CMS 回收器，就引入了预清理和再标记步骤，G1 引入 SATB (snapshot at the beginning)了。这些都会占据更多的 CPU 资源。

### 并发 GC 和并行 GC 比起来有什么优缺点？

分析：考察的是这两大类 GC 的设计初衷。并发 GC 设计初衷是为了不停下应用线程，也是为了降低停顿时间。而并行 GC 则是纯粹为了加快 GC 速度。

因此，并发 GC的优点是应用不停，停顿时间短；并行 GC则是吞吐量大。

答案：并发 GC 优点在于整个 GC 过程中，大多数时候应用不需要停下来，因此应用能够平稳运行，整个STW的时间也短。

并行 GC 则专注在吞吐量，停顿时间会比并发GC长。

（给出选择建议）对于互联网应用这种强调停顿时间的应用来说，一般选择并发 GC；而对于批处理之类的应用，则可以使用并行 GC。

#### 类似问题
- 并发 GC 性能比并行 GC 好？错
- 并行 GC 性能比并发 GC 好？错
- 什么时候用并发 GC？
- 什么时候用并行 GC？

### 什么是安全点？

分析：这个问题其实并没有非常标准的回答，理论上也应该很少有人关注，不过我被问过几次，姑且放这里。一般来说，只有JVM 才会面这个问题。别的语言应该虽然有类似的概念——比如说 golang，但是面试没遇到过。

答案：安全点是指在这个时间点上，引用关系不会被改变，常见的安全点有方法调用和循环。GC一般要从安全点开始，当准备 GC 的时候，会等待所有的线程都到达安全点，这就是 STW 的实现方式。但是也有别的问题，需要利用到安全点，例如我们尝试 dump 整个堆栈。

#### 如何引导
- 在谈到 STW 的时候，可以聊起是怎么进入 STW 状态的，就是依靠安全点

### 如何判断一个对象存活？
分析：一般来说，面试官问出这个问题，其实是希望你回答什么标记过程啥的。但是呢，这个问题的答案，准确来说，是问的引用计数和可达性分析，所以先回答可达性分析，直接命中面试官的下怀，然后再补充引用计数。

答案：这主要有两种手段，可达性分析和引用计数。

可达性分析目前主流是采用三色标记法，三色标记法巴拉巴拉（接上面什么是三色标记法），标记结束之后白色的对象就是死掉的对象。在并发标记的时候，黑色的对象是可能存活对象，但是并不能确保一定存活（亮点也在这里，就是并发三色标记的活死人问题）；

引用计数，则要简单很多。计数为 0 就是死掉了，不过考虑到循环引用的问题，应该说，除了循环引用之外的引用数量是0，代表已经死了（亮点在要解释循环引用的特殊之处，它们虽然计数不为0，但是已经死掉了）。

#### 类似问题
- 如何知道一个对象可以被回收了？
- 引用计数不为0，对象一定活着吗？

### GC root 是什么？
分析：本来这个问题，应该和具体的实现结合在一起来考察的。比如说，准确的问法是，我用 CMS + Parallel New，那么在 Full GC 的时候，GC root 包含哪些？不过很多时候面试官都不严谨，所以我们可以从一般原则上回答，然后举个例子。这个问题，在具体语言的 GC 上还会进一步分析。

答案：GC root，顾名思义，是指在GC启动的时候必然存活的一组对象。一般来说，GC root 包含：
1. 栈上对象，于 Java 来说，还包含本地方法栈；
2. 全局对象，如常量池；
3. 非收集部分指向收集部分的引用。常见于分代 GC 和增量式GC中

### Minor GC 是什么？Major GC 是什么？
分析：茴香豆的茴字有几种写法的问题。

答案：Minor GC 是指年轻代的垃圾回收，Major GC 是指 Full GC。

### 为什么要分代？
分析：其实分代不是最开始就有的，而是大家观察到了分代假说的两个现象之后，才有了分代的设计。那么分代究竟是为什么引入呢？很简单，就是既然新对象很容易就死掉，老对象很难死掉，那我们就分开着两个，然后新对象朝生夕死，这样就可以每次都回收大量的空间。而老对象待着的地方，我就可以少回收，反正也回收不到东西，只在确实没空间了我再回收。所以分代，核心就是为了提高 GC 效率。

但是还有一个难点，就是为啥有的 GC 实现是不分代的。这个问题的答案可以作为我们回答的亮点。

答：（首先回答分代假说，这是从理论上直接回答了这个问题）分代是基于分代假说，即新对象很容易死，老对象不容易死。（下面点出核心，就是为了效率）因此如果我们采用分代，依据存活时间来将对象放到不同的内存区域，那么在回收的时候，就可以只回收年轻代，或者一起回收。这样一来，回收效率高，（效率高的两个方面）一方面是停顿时间短（也可以说是资源消耗低），一方面是能够回收更多的内存。

（下面我们指出并不是所有的 GC 实现都是分代的，作为一个亮点）但是并不是所有的 GC 都是分代，例如Java 的 ZGC，golang GC 都不是分代的。绝大部分情况下，分代都要比不分代效率高，但是分代带来的了额外的问题：
1. 实现难度高，分代 GC 的实现难度，要比非分代高一个量级；
2. 较难配置和优化，所有的分代 GC 都面临一个问题，就是各个分代的大小该如何确定；

#### 类似问题
- 为什么有些 GC 没有采用分代

### 对象死了就立刻会被回收吗？

答案：并不是。只有触发了 GC 才会被回收。

### 对象死了一定会被回收吗？

答案：并不是，有些语言设计了复活机制，那么它可以在被回收之前，重新活过来（也就是又有了新的引用指向它）。比如说 Java。