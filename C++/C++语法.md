# C++基础语法

## 面向对象和面向过程语言区别

面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用

面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为

## 指针与引用区别

1. 指针是一个变量，存储的是一个地址，引用是原变量的别名
2. 指针可以有多级，引用只有一级
3. 指针可以为空，引用不能为NULL且在定义时必须初始化
4. 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
5. sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小


<引导出什么时候用指针或引用>

### 什么时候指针，什么时候引用，什么时候值传递

仅用传递的值，不对值修改

        （1）如果数据对象很小，如内置数据类型或小型结构，使用按值传递。
        （2）如果数据对象是数组，则使用指向const的指针。
        （3）如果数据对象是类对象，则使用const引用。

修改传递过来的值

      （1）如果数据对象是内置数据类型，则使用指针/引用。
      （2）如果数据对象是数组，则只能使用指针。
      （3）如果数据对象是类对象，则使用引用。

子问题1：
#### 常量指针与指针常量的区别
- 指针常量是一个指针，读成常量的指针，指向一个只读变量
- 常量指针是一个不能给改变指向的指针：指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了

子问题2：
#### 数组指针与指针数组的区别
- 数组指针：是一个指针变量，指向了一个一维数组，`int (*p)[233]`
- 指针数组：是一个数组，只不过数组的元素存储的是指针变量,`int *p[233]`

## malloc/free与new/delete区别

相同：

- 都可用于内存的动态申请和释放

不同：

- 后者是C++运算符，前者是C/C++语言标准库函数
- new自动计算要分配的空间大小，malloc需要指定空间大小
- new调用名为**operator new**的标准库函数分配足够空间并调用相关对象的构造函数，返回的是对象类型的指针
- malloc内存分配成功则返回void*
- delete对指针所指对象运行适当的析构函数；然后通过调用名为**operator delete**的标准库函数释放该对象所用内存。
- malloc失败返回空指针，new失败抛出异常

子问题1：

### 为什么加入new/delete：

- 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数

子问题2：

### 被free的内存会直接返回函数？

不是的，被free回收的内存会首先一个双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时该双链表也会尝试对小块内存进行合并，避免过多的内存碎片。



## 变量声明与定义区别

- 声明仅提供变量的声明的位置及类型提供给编译器，并不分配内存空间；
- 定义要在定义的地方为其分配存储空间
- 相同变量可以在多处声明（外部变量extern），但只能在一处定义



## strlen与sizeof区别

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。

## C++与其他语言的比较（优点）
### C++与Python区别

- Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的
- 二者都可跨平台，python效率没有C++高
- C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等



### C++与C语言区别

- 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的,一个面向过程，另一个面向对象
- C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分
- 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的
- static：C中仅用于定义局部静态变量和全局静态变量，C++还会定义静态成员变量和静态成员函数，与类绑定
- 结构体：C中结构体没有函数成员，数据成员也没有private、protected等访问限制，此外也没有继承关系




## define宏定义与const的区别
从三方面回答：
1. 发挥作用时间不同
2. 占用空间不同
3. 有无类型检查

具体解释：

- define是在编译的**预处理**阶段起作用，而const是在**编译、运行**的时候起作用
- define只做替换，不做类型检查和计算，容易产生错误
- const常量有数据类型，编译器可以对其进行类型安全检查
- define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠

同样还有define与typedef区别
1. typedef在编译阶段有效，类型检查；define是宏定义，仅替换
2. define没有作用域的限制，而typedef有自己的作用域


## define宏加括号和不加括号的区别
当宏中包含运算符时要在最外层加括号，不然可能会出错

```c++
#define A(x) x+x
#define B(x) (x+x)

```
执行`A(x)*A(x)`与`B(x)*B(x)`结果不同

## C++中static作用

- 不考虑类

  - static 修饰全局变量或函数的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以
  
  - 默认初始化为0，都在全局初始化区data段

  - 在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放

- 类

  - static成员变量：只与类关联。定义时要分配空间，不能在类声明中初始化，必须在**类定义体外部初始化**，初始化时不需要标示为static；可以被非static成员函数任意访问
  - static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；**不能被声明**为const、虚函数和**volatile**；可以被非static成员函数任意访问



## C++的顶层const与底层const

- **顶层**const：指的是const修饰的变量**本身**是一个常量，无法修改,指的是指针
- **底层**const：指的是const修饰的变量**所指向的对象**是一个常量，指的是所指变量



## extern 

extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用

与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用

extern C用法

- **指示编译器这部分代码按C语言的进行编译，而不是C++的**
- 够**正确的在C++代码中调用**C语言



## 野指针与悬空指针

- 野指针，
  - 指的是**没有被初始化过**的指针
  - 指针释放后未置空
  - 指针操作超出了变量的作用域
  - 解决：为了防止出错，对于指针初始化时都是赋值为 nullptr，这样在使用时编译器就会直接报错，产生非法内存访问。

- 悬空指针，指针最初指向的**内存已经被释放了的一种指针**
  - 解决：引入智能指针，避免悬空指针



## 类型安全

- 类型安全的代码**不会试图访问自己没被授权的内存区域**
- C++如何保障
  - 操作符new返回的指针类型严格与对象匹配，而不是void*
  - C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的
  - **dynamic_cast**关键字，使得转换过程更加安全


## 浅拷贝与深拷贝区别

- 浅拷贝
  - 将源对象的值拷贝到目标对象中，如果对象中有某个成员是指针类型数据，并且是在堆区创建，则使用浅拷贝仅仅拷贝的是这个指针变量的值，没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变

- 深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值



## 内联函数与宏定义区别

- 宏只做简单字符串替换（预处理）。而内联函数**可以进行参数类型检查**（编译时），且具有返回值



## 大小端存储

- 大端存储：字数据的高字节存储在低地址中
- 小端存储：字数据的低字节存储在低地址中
- 在Socket编程中，往往需要将操作系统所用的**小端存储的IP地址转换为大端存储**，这样才能进行网络传输



## volatile、mutable与explicit关键字用法
volatile

  - volatile 关键字是一种类型修饰符，**用它声明的类型变量表示可以被某些编译器未知的因素更改**，编译器不要对该变量访问擅自优化。
  - 要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据

  - **volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型**。volatitle是防止编辑器对该代码优化，
  
const

- 要在const函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutable来修饰，并且放在函数后后面关键字位置

explict

- explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以**显示的方式进行类型转换**
  - 因为仅含一个参数的构造函数和除了第一个参数外其余参数都有默认值的多参构造函数承担了两个角色。 第一个是成为带参数的构造函数，第二个是一个默认且隐含的类型转换操作符



## C++中几个new

- **plain new**,是普通的new，就是我们常用的new
- **nothrow new**:在空间分配失败的情况下是不抛出异常，而是返回NULL
- **placement new** : `operator new`重载版本， 在一块已经分配成功的内存上重新构造对象或对象数组，做的唯一一件事情就是**调用对象的构造函数**
  - 创建的对象使用完毕，必须**显式的调用他们的析构函数**来销毁，但不会释放内容
    - 如何释放内存
      - 缓冲区在堆，`delete []buf`
      - 在栈，跳出作用域，内存自动释放
  - 构造起来的对象或数组大小并不一定等于原分配的内存大小

## malloc、realloc、calloc区别

- malloc：申请的空间的值是随机初始化的
- calloc：申请的空间的值是**初始化为0**的
- realloc：给动态分配的空间**分配额外的空间**，用于扩充容量



## 什么是内存泄漏？如何检测与避免

- 由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况
- 没有将父类的析构函数定义为虚函数，当父类的指针指向子类对象时，delete该对象不会调用子类的析构函数
- 后果：
  - 性能下降到内存逐渐用完，导致另一个程序失败

解决办法：
- 智能指针
- 把new和delete全部都封装到构造函数和析构函数中，保证任何资源的释放都在析构函数中进行
  
如何定位
  - 检查内存使用情况，Linux下是`ps -aux`

  - Linux下可以使用**Valgrind**工具




## 面向对象的三大特性

1. 继承：**让某种类型对象获得另一个类型对象的属性和方法**
2. 封装：**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
3. 多态：基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式。**重载实现编译时多态，虚函数实现运行时多态**
   1. 分为以下两类
      1. 覆盖：指子类重新定义父类的虚函数
      2. 重载：是指允许存在多个同名函数，而这些函数的参数表不同
   2. 静态多态与动态多态
        -   静态多态：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明
        - 动态多态
              对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。具体实现就是c++的虚函数
   3. 实现动态多态条件：
      1. 要有继承关系 -
      2. 要有虚函数重写（被 virtual 声明的函数叫虚函数）
      3. 父类指针（父类引用）指向子类对象
   4. 动态多态原理
      1. 当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储类虚函数指针的数据结构， 虚函数表是由编译器自动生成与维护的。virtual 成员函数会被编译器放入虚函数表中，存在虚函数时，每个对象中都有一个指向虚函数表的指针（vptr 指针）。在多态调用时, vptr 指针就会根据这个对象在对应类的虚函数表中查找被调用的函数，从而找到函数的入口地址。



## C++的四种强制转换

- `reinterpret_cast<type-id> (expression)`：完成任意指针类型向任意指针类型的转换

  - 既不会有指向内容的检查，也不会有指针本身类型的检查

- `const_cast<type_id> (expression)`：设置或移除指针所指向对象的const
  - **常量**指针被转化成**非常量**的指针，并且仍然指向原来的对象
  - **常量**引用被转换成**非常量**的引用，并且仍然指向原来的对象
  - const_cast一般用于修改底指针

- `static_cast <type-id> (expression)`：将expression转为type-id
  - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
    - 派生类指针/引用转基类是安全
    - 基类指针/引用转派生类，因无动态类型检查，不安全
  - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum
  - 空指针转换成目标类型的空指针
  - 不能转换掉expression的const、volatile
  
- `dynamic_cast <type-id> (expression)`：
  - 只能用于含虚函数的类的指针或引用

    - 运行时转换，需要知道类对象的信息

    - 通过虚函数表获取该信息
      - 通过虚函数表指针，获得该类对象的所有虚函数，用来判断对象有无继承关系

  - 确保目标指针类型指向一个有效且完整的对象

  - 允许派生类向基类转换

  - 基类向派生类转换，仅当转过去的指针指向的目标对象有效且完整

    - 返回空指针表示转换失败

    - 若是无法完成的引用转换，抛出bad_cast

**RTTI(Run-Time Type Identification)**；为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型

  - 运行时类型信息，指在运行时确定对象类型



## 是否遇到coredump，如何解决

- 程序由于异常或者bug在运行时异常退出或者终止



## strcpy与memcpy区别

- 前者仅复制字符串，后者复制任意类型
- 前者遇到'\0'停下，后者根据第三个参数决定复制的长度




## 静态绑定与动态绑定

- 静态类型：声明时的类型，编译时确定，无法更改
- 动态类型：运行期间决定，可以更改
- 静态绑定：绑定的是对象的静态类型
- 动态绑定：绑定动态类型




## 回调函数

- 相当于一个中断处理函数，由系统在符合你设定的条件时自动调用
- 1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用
- 函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数



## 一致性哈希，负载均衡相关
- 哈希算法存在的问题
  - 哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景
- 一致性哈希算法
  - 概念
    - 指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响
  - 应该满足的条件
    1. 均衡性：哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用
    2. 单调性：当缓冲区大小变化时，一致性哈希(Consistent hashing)尽量保护已分配的内容不会被重新映射到新缓冲区
    3. 分散性：避免相同的内容被不同的终端映射到不同的缓冲区的情况
    4. 负载：降低缓冲的负荷
- 环形hash空间
  - 将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置
  - 将objectA、objectB、objectC、objectD四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器
  - 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化
  - 环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置
  - 为了解决数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点

可有数据库解决缓存一致性问题引导而来，一致性哈希+singleflight
## 动态编译与静态编译

- 静态编译：在编译时，把所有模块都编译进可执行文件里，当启动这个可执行文件时，所有模块都被加载进来
  - 静态库优点：代码的装载速度快，执行速度也比较快
  - 缺点：
    - 程序体积会相对大一些
    - 如果静态库需要更新，程序需要重新编译
    - 如果多个应用程序使用的话，会被装载多次，浪费内存

- 动态编译：是将应用程序需要的模块都编译成动态链接库，启动程序（初始化）时，这些模块不会被加载，运行时用到哪个模块就调用哪个
  - 缺点：
    - 只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库
    - 如果没有安装对应的运行库，则用动态编译的可执行文件就不能运行
  - 优点：
    - 缩小了执行文件本身的体积
    - 是加快了编译速度，节省了系统资源



## 为什么不把所有函数写成内联

- 函数体内的代码比较长，将导致内存消耗代价
- 函数体内有循环，函数执行时间要比函数调用开销大

## 内联函数的作用

- 函数调用时候需要创建时间、参数传入传递等操作，造成了时间和空间的额外开销。
- 通过编译器预处理，在调用内联函数的地方将内联函数内的语句复制到调用函数的地方，也就是直接展开代码执行，从而提高了效率，减少了一些不必要的开销。同时内联函数还能解决宏定义的问题



## C++的程序内存分区

- 栈区：在执行函数时，**函数内局部变量**的存储单元都可以在栈上创建。函数执行结束时这些存储单元自动被释放

- 堆区：由 new分配的内存块。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收
- 堆区与栈区之间有一个共享区，也就是文件映射区
- BSS段：程序中**未初始化的全局变量和静态变量**的内存区域
- data段：**已初始化的全局变量和静态变量**的内存区域

- 代码区：存放函数体的二进制代码，只读，**不允许修改**。头部还会包括一些**只读常量**

这里会牵扯到堆与栈的区别，详见OS文件夹

## 内存错误检测,GDB的使用

`Address Sanitizer（ASan）`是一个快速的内存错误检测工具，从gcc 4.9开始支持

使用步骤：

1. 用`-fsanitize=address`选项编译和链接你的程序。

2. 用`-fno-omit-frame-pointer`编译，以得到更容易理解stack trace。

3. 可选择-O1或者更高的优化级别编译

4. ```
   gcc -fsanitize=address -fno-omit-frame-pointer -O1 -g use-after-free.c -o use-after-free
   ```




## RAII

- 直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源



## 2.左值引用和右值引用

- 取地址的、有名字的就是左值；反之，不能取地址的、没有名字、临时值，就是右值，诸如表达式中间结果/函数返回值（可能拥有变量名，也可能没有）

- 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值
  - 右值引用的意义：移动语义，实现各种情形下对象的资源所有权转移

- 右值引用特点
  - 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去
  
  - 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值
  
  - T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。
  
  - ```c++
     int a = 10;
     int& b = a; //b是左值引用
     int& c = 10; //错误，c是左值不能使用右值初始化
     int&& d = 10; //正确，右值引用用右值初始化
     int&& e = a; //错误，e是右值引用不能使用左值初始化
     const int& f = a; //正确，左值常引用相当于是万能型，可以用左值或者右值初始化
     const int& g = 10;//正确，左值常引用相当于是万能型，可以用左值或者右值初始化
     const int&& h = 10; //正确，右值常引用
     const int& aa = h;//正确
     int& i = getInt(); //错误，i是左值引用不能使用临时变量（右值）初始化
     int&& j = getInt(); //正确，函数返回值是右值
     fun(10); //此时fun函数的参数t是右值
     fun(a); //此时fun函数的参数t是左值
     return 0;
    ```
  
- 应用场景

  - **实现移动语义，避免拷贝，从而提升程序性能**
    - 移动语义：使用std::move可以强制将左值引用转为右值引用。而对于右值引用，程序可以调用移动构造函数进行对象的构造，减少了原来调用拷贝构造函数的时候很大的开销
  - 都实现了以**右值引用为参数**的`移动构造函数`和`移动赋值重载函数`，或者其他函数，最常见的如std::vector的`push_back`和`emplace_back`。参数为左值引用意味着拷贝，为右值引用意味着移动。
  - 模板函数按照参数实际类型转发，所谓“完美转发”


## C++多态如何实现

1. 在基类的函数前加上**virtual**关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数
2. 多态原理
   1. 虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表
   2. 虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针
   3. 实现多态过程：
      - 编译器会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址
      - 会在每个对象的前四个字节中保存一个虚表指针，即**vptr**，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数
      - 在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数
      - 当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
      - 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面
3. 虚函数表带来的成本问题
   - 使用虚函数时，对于内存和执行速度方面会有一定的成本：
      - 1. 每个对象都会变大，变大的量为存储虚函数表指针； 
         2. 对于每个类，编译器都会创建一个虚函数表
         3. 对于每次调用虚函数，都需要额外执行一个操作，就是到表中查找虚函数地址



## C++程序优化方法
空间足够时，可以将经常需要读取的资源，缓存在内存中
尽量减少大内存对象的构造与析构
尽量使用C++11的右值语义，减少临时对象的构造
优化线程或进程的同步方式，能用原子操作的就不用锁
优化堆内存的使用，如果有内存频繁的申请与释放，可以考虑内存池】


## 内存问题
1. 指针悬挂/野指针，用shared_ptr和weak_ptr就可以解决
2. 重复释放，用boost的scoped_ptr或者仔细检查，只在对象析构的时候释放一次
3. 内存泄漏，也可以用scoped_ptr
4. new[]和delete不配对，把new[]统统换成vector就行


## 模板和继承，这个区别是什么？

第一点：

模板可以生成一组类或者函数，这些类或函数的实现都是一样的

继承是事物之间的一种关系，从父类到子类实际上就是从普遍到特殊、从共性到特性

第二点：

模板和继承都是多态性的体现，继承是运行时的多态性，模板是编译时的多态性。

第三点：

继承是数据的复制、模版是代码的复制。

模板函数在编译完成之后，会生成对应参数数类型的函数；

继承是对虚表、数据的复制



## C++如何保证线程安全

什么是线程安全：

在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染

1. 给共享的资源加把锁，保证每个资源变量每时每刻至多被一个线程占用
2. 让线程也拥有资源，不用去共享进程中的资源。如： 使用threadlocal可以为每个线程的维护一个私有的本地变量