# Linux下的socket编程

## 什么是Socket？

**对于 UNIX 系的操作系统，是利用 Socket 文件系统，Socket 是一种特殊的文件——每个都是一个双向的管道。一端是应用，一端是缓冲区（服务器）**


有客户端连接服务端时，服务端 Socket 文件中会写入这个客户端 Socket 的文件描述符。进程可以通过 accept() 方法，从服务端 Socket 文件中读出客户端的 Socket 文件描述符，从而拿到客户端的 Socket 文件。

## 进程如何监听关注集合的状态变化，比如说在有数据进来，如何通知到这个进程？
**所有关注的 Socket 状态发生了变化，都由一个线程去处理，构成了 I/O 的多路复用问题**

Linux提供三种多路复用问题的API：select、poll、epoll

- select
  ```c++
  fd_set read_fd_set, write_fd_set, error_fd_set;

  while(true) {

  select(..., &read_fd_set, &write_fd_set, &error_fd_set); 

  }
  ```
  
  
  - 具体操作
    - 每次 select 操作会阻塞当前线程，在阻塞期间所有操作系统产生的每个消息，都会通过遍历的手段查看是否在 3 个集合当中
    - 上面程序read_fd_set中放入的是当数据可以读取时进程关心的 Socket；write_fd_set是当数据可以写入时进程关心的 Socket；error_fd_set是当发生异常时进程关心的 Socket

  - **用户程序可以根据不同集合中是否有某个 Socket 判断发生的消息类型**：FD_ISSET
    - FD_SETSIZE 是一个系统的默认设置，通常是 1024.
    - FD_SETSIZE 是一个系统的默认设置，通常是 1024

- poll
  - 阻塞调用，它将某段时间内操作系统内发生的且进程关注的消息告知用户程序
  - poll 函数的第一个参数告知内核 poll 关注哪些 Socket 及消息类型
  - poll 调用后，经过一段时间的等待（阻塞），就拿到了是一个消息的数组
    - 遍历这个数组中的消息，能够知道关联的文件描述符和消息的类型
    - 消息类型判断接下来该进行读取还是写入操作
    - 通过文件描述符，可以进行实际地读、写、错误处理

  - 内核在产生一个消息之后，依然需要遍历 poll 关注的所有文件描述符来确定这条消息是否跟用户程序相关

- epoll
  - epoll 将进程关注的文件描述符存入一棵二叉搜索树，通常是红黑树的实现.当内核发送一个事件，能够立马找到进程是否关注该事件
  - 当有关注的事件发生时，epoll 会先放到一个队列当中.一个双链表，存储就绪的文件描述符列表
    - 调用epoll_wait，测此链表中是否有数据，有的话直接返回

  - 优势
    - 内部使用红黑树减少了内核的比较操作
    - 非阻塞的模型更容易处理各种各样的情况。程序员习惯了写出每一条语句就可以马上得到结果，这样不容易出 Bug

  - 两种触发模式
    - level （水平）模式：只要文件描述符还有数据可读，每次epoll_wait就会返回它的事件（只要有数据就触发）
    - edge （边缘）模式：只有数据流到来的时候才触发，不管缓冲区是否还有数据（只有数据流到来才会触发）


**select/poll/epoll 三者都是同步调用**，可以确定程序执行的顺序的调用