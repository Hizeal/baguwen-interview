# Redis为什么快

String、Hash 和 Set使用哈希表实现，复杂度 O(1)

SortedSet 也使用跳表进行优化，复杂度 O(logn)

List采用压缩列表加双向链表则比较慢 O(n) 复杂度,但是 Push、Pop 等对表头尾元素的操作效率很高，所以需要因地制宜的使用 List,将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合

# Redis 数据结构

回答的是 Redis 值对象的数据结构（表象），还是底层实现。大多数情况下，你应该从表象出发，即值对象的角度出发，而后讨论每一种值对象的可能的底层实现。如果记不住全部的底层实现，可以只讨论重点的几个。先看图：

![值对象](img/value_object.png)

![底层数据结构](img/data_structure.png)

总体回答的讨论就是“某种值对象-有什么实现-某种实现的特点”。

答案：从使用的角度来说，Redis 有五种数据结构（注意，我们这里按照第一张图来回答，即从值对象的角度出发）

- 字符串对象，即我们设置的值是一个简单的数字或者字符串；
- 列表对象，即值是一个列表，存储多个元素。从底层实现上来说，有`ziplist`和`linkedlist`两种实现；
- 字典对象，即值本身就是一个字典。从底层实现上来说，有`ziplist`和`hashtable`俩中实现；
- 集合对象，即值是一个集合（Set）。底层有`intset`和`hashtable`两种实现；
- 有序集合对象，即值是一个有序的集合，也就是zset。底层有`ziplist`和`skiplist`两种实现；



## 扩展点

### Redis 使用的字符串有什么特点？

分析：考察底层数据结构特点。

答案：Redis 使用的字符串，叫做 SDS。SDS 的特点是：

1. 直接存储了字符串长度，可以常量时间获得长度；
2. SDS 采用了预分配和懒回收的策略来分配内存，可以减少内存分配次数；
   1. buf保存字符串，free记录buf中未使用的字节的个数

#### 类似问题
- SDS 有什么特点
- SDS 和 C 字符串比起来有什么优点
- Redis 为什么不直接使用 C 字符串

#### 如何引导
可以考虑在前面回答字符串对象的时候主动谈起。


### Redis 的 hashtable 是如何实现的

分析：Redis 的渐进式 rehash 是很有特色的。要结合各自语言的 hashtable 实现来做交叉对比。例如，对于 Java 的开发者来说，可以比较 Redis 的 rehash 和 Java HashMap 的 rehash 过程；对于 golang 来说，Redis 的 rehash 过程和 map 的底层实现理念接近，也可以一并说起来。

而后要再一次点出，采用渐进式 rehash 的优缺点，即采用渐进式 rehash 会时总的开销增大，但是这种开销被平摊到了每次访问数据中，是一种取舍。

在回答完毕之后，为了万无一失，可以再一次提起，就是说字典除了可以用哈希表实现，也可以用`ziplist`来实现。

答案：（关于哈希算法这一段，可以作为候选，因为哈希算法名字很难记）Redis 采用 MurmurHash2 （么么哈希），该算法效率高，随机性好，可以减少冲突可能。

Redis的哈希表是采用了拉链法来解决冲突，在冲突的时候，会将元素加在表头，以加快速度。

Redis 的扩容比较有特色，采用的是渐进式 rehash。即 Redis 实际上维持了新旧两张表，迁移发生的时候，Redis 并不是直接把数据迁移到新的表，而是在后续删改查的时候逐步挪过去。

（以下是和特定语言进行比较，看你的语言里面 rehash 是如何实现的）
- (golang 版本)
  - go 语言的 map 实现理念很接近。golang 的 map 的扩容也是渐进式的，也是在访问数据过程中逐步完成迁移。
- (C++ 版本) 
  -  以2倍的原桶容量（2*old_bucket_count）分配一个新的桶数组
  -  遍历原桶数组，计算原桶数组中的每个元素在新桶数组中的位置，并插入到相应的桶中
  -  所有元素迁移完成之后，释放原桶数组

所以，当查找某个 key 的时候，大概是先去原表里面找，找不到就去新表里面找。如果在原表找到了，就同时执行迁移逻辑。


（总结，升华主题，强调一下渐进式的改进并不是毫无缺点的。这也是回答“为什么使用渐进式 rehash ”）总体而言，渐进式 rehash 可以带来更平滑的响应时间。但是渐进式的 rehash 也会带来总体开销比一次性迁移开销大的缺点。



关键点：拉链法，MurmurHash2（么么哈希），渐进式 rehash

#### 类似问题
- 为什么要使用渐进式 rehash
- 渐进式 rehash 有什么缺点？（总开销大，每次查询都比一次性 rehash要慢）
- Redis 的哈希表扩容有什么特色
- Redis 的哈希表如何扩容

#### 如何引导
- 讨论到你的语言的 map 的底层实现的时候，你可以用 Redis 作为横向对比

### Hash对象如何实现

**ziplist**和**hashtable**

数据量小的时候使用 ziplist 节省空间，数据量大的时候用 hashtable 以降低操作复杂度

ziplist；将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾

保证：

- 保存了同一键值对的两个节点总是紧挨在一起
- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向

hashtable：字典作为底层实现，每个键值对都使用一个字典键值对


#### 二者如何转换？

使用ziplist：
- 所有键值对的键和值的字符串长度都小于 64 字节
- 键值对数量小于 512 个

否则使用hashtable编码


### Redis 里面的 ziplist 是如何实现的？有什么用？

分析：考察底层数据结构。`ziplist`在 Redis 里面是一个很重要的结构，要紧紧围绕`ziplist`节省内存，结构紧凑，搜索快速的特点来回答。要想答出特色来，要先回答`ziplist`的基本特点，要把重点放在`ziplist`增删改数据时候的行为，关键点在于两个，一个是数据移动，一个是连锁更新。

答案：`ziplist`是一个很特殊的列表，它的内存类似数组那样是连续，但是每个元素的大小却不相同。`ziplist`通常用于单个数据小，并且数据量不多的情况。在 Redis 里面，`ziplist`用于组成有序集合，字典和列表三种值对象。

（回答第一个要点，元素移动）
`ziplist`能够在`O(1)`的时间内完成对头尾的操作（因为`ziplist`记录了首尾节点），但是一般的增删改查，都是`O(N)`的。这是因为`ziplist`是一个连续内存的结构，找到位置`i`，需要从头部开始遍历，而在**增删**的时候需要将位置`i`之后的元素移动（增往后移动，删往前移动）。

（回答第二个要点，连锁更新）
尤其是，因为`ziplist`的节点存储了前一个节点的长度`prelen`，所以，当前一个节点发生变更的时候，就需要更新长度`prelen`。而 Redis 为了节约内存，`prelen`有一个字节和五个字节两种长度。举例来说，假设前一个节点，最开始的长度是254，而后更新成了256，那么当前节点原本一个字节能够放下`prelen`，不得不扩展到五个字节。假如说当前节点最开始长度也是254，那么`prelen`扩展到五个字节之后就变成了258，当前节点的后一个节点，就不得不跟着扩展。

这就是所谓的连锁更新，它使得一个增删改操作，最坏的时候是`O(N^2)`。这也是为什么`ziplist`只适合放置小数据，少数据的原因。（从这里也可以解释为什么前面那些编码，都是限制数据小于64字节，并且数量少于512）

关键点：内存连续，数据移动，连锁更新，

#### 类似问题
- 如何往`ziplist`里面插入或者删除一个元素？（考察数据移动和连锁更新）
- 什么时候会触发连锁更新？
- `ziplist`在最糟糕的情况下性能如何？（考察连锁更新）
- 为什么数据量大的时候不用`ziplist`？（考察`ziplist`的特点，特别是增删改查的行为）
- `ziplist`的操作效率是多少？（O(N)，一般情况下，只要不是操作头尾，即PUSH，POP之类的操作，都是）
- 删除会引起连锁更新么？（当然可能！增删改都可能！）
- 为什么使用`ziplist`？（考察`ziplist`特点）
- 什么情况下使用`ziplist`？ （同上，单个数据小，数据量也少）

#### 如何引导
- 讨论到了有序列表的时候
- 讨论到 ArrayList, LinkedList 的时候。`ziplist`的实现不同于这两种，所以可以扩展到这里

### Redis 的整数集合(intset)是什么？有什么特色

分析：考察底层数据结构，核心就在于理解`intset`的**升级不降级**的特性。

答案：`intset`是一个数组结构，用于存储整数类型，里面的元素是唯一的。它可以存放16、32、64位的整数。如果元素位数变大，那么就会触发升级过程。例如原本存储的元素都是16位整数，现在插入一个32位的整数，那么 Redis 需要按照32位重新计算内存大小，并且分配内存，迁移原本的数据，而后将新数据插入。有一点需要注意的是，Redis并不支持降级。

#### 类似问题
- 如果我有一个小的整数数据集想要放到 Redis，Redis会用什么结构来存储？
- Redis 的`intset`是否支持降级？

### Redis中zset底层实现
#### ziplist实现
1. 什么时候使用

- 成员的数量小于128 个；
- 每个 member （成员）的字符串长度都小于 64 个字节

2. 组成

- 当前ziplist占用总字节数
- 尾部元素相对起始偏移量
- entry数量：需要完全遍历entry
- entry：具体数据线，可以是字节数组或正数
  - entry 的第一个节点保存 member，第二个节点保存 score。依次类推，集合中的所有成员最终会按照 score 从小到大排列
- zlend：标识ziplist内存结束点作用
#### skiplist实现

插入、删除、查找的时间复杂度均为 O(logN)



性质

（1）由很多层结构组成；
（2）每一层都是一个有序的链表；
（3）最底层(Level 1)的链表包含所有元素；
（4）如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现；
（5）每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。

## 总结

Redis 的问题大同小异，套路就是：
1. 你用过XXX结构么？
2. 如果我想存储XXX特点的数据，你会用什么？
3. 如果我想存储XXX特点的数据，Redis 会用什么结构？

而后就是前面列举的几个有很强个性的数据结构的实现原理。在复习的时候，一定要记住值对象和底层实现的关系。大概的思路就是“值对象——支持的数据结构——数据结构特点”

还要把握住不同底层实现切换的逻辑。比如说字典，底层可能是`ziplist`和`hashtable`，那么要把握住两个点：
1. 什么时候会从`ziplist`转化到`hashtable`
2. 怎么转化

第二个问题`怎么转化`其实很好回答，所有的底层实现转换，都是遍历老的实现的数据，一个个迁移过去。例如`ziplist`迁移`hashtable`，就是遍历`ziplist`，对里面每一个元素做哈希，放到对应的位置。

Redis 还有一个设计理念，就是先凑合，不行再升级。最开始 Redis 总是选择能够节省内存的，紧凑的数据结构，后面发现不行了，再来升级。


