# GO

## 竞态

同一块内存同时被多个 goroutine 访问。我们使用 go build、go run、go test 命令时，添加 -race 标识可以检查代码中是否存在资源竞争

解决方法：
```go
sync.Mutex
sync.RWMutex
```

## 值接收者和指针接收者的区别？
1. 方法的接收者:

   - 值类型，既可以调用值接收者的方法，也可以调用指针接收者的方法；

   - 指针类型，既可以调用指针接收者的方法，也可以调用值接收者的方法。

2. 接口的接收者

   - 以值类型接收者实现接口，类型本身和该类型的指针类型，都实现了该接口；

   - 以指针类型接收者实现接口，只有对应的指针类型才被认为实现了接口。


3. 通常我们使用指针作为方法的接收者的理由：

   1. 使用指针方法能够修改接收者指向的值。

   2. 可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。


## Go有什么优势或特点
- Go 允许跨平台编译，编译出来的是二进制的可执行文件，直接部署在对应系统上即可运行。
- Go 在语言层次上天生支持高并发，通过 goroutine 和 channel 实现。channel 的理论依据是 CSP 并发模型， 即所谓的通过通信来共享内存；Go 在 runtime 运行时里实现了属于自己的调度机制：GMP，降低了内核态和用户态的切换成本。
- Go 的代码风格是强制性的统一，如果没有按照规定来，会编译不通过。

## Go的内存分配

内存池 + 多级对象管理。内存池主要是预先分配内存，减少向系统申请的频率；多级对象有：mheap、mspan、arenas、mcentral、mcache。它们以 mspan 作为基本分配单位

- 当要分配大于 32K 的对象时，从 mheap 分配。
- 当要分配的对象小于等于 32K 大于 16B 时，从 P 上的 mcache 分配，如果 mcache 没有内存，则从 mcentral 获取，如果 mcentral 也没有，则向 mheap 申请，如果 mheap 也没有，则从操作系统申请内存。
- 当要分配的对象小于等于 16B 时，从 mcache 上的微型分配器上分配。

## defer、panic、recover用法
defer 函数调用的顺序是后进先出，当产生 panic 的时候，会先执行 panic 前面的 defer 函数后才真的抛出异常。一般的，recover 会在 defer 函数里执行并捕获异常，防止程序崩溃。

## Go中对nil的Slice和空Slice的处理是一致的吗

JSON 标准库对 nil slice 和 空 slice 的处理是不一致
- slice := make([]int,0）：slice不为nil，但是slice没有值，slice的底层的空间是空的
- slice := []int{} ：slice的值是nil，可用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值

## Go主协程如何等其余协程完再操作？

使用sync.WaitGroup。WaitGroup，就是用来等待一组操作完成的。

WaitGroup内部实现了一个计数器，用来记录未完成的操作个数。
- Add()用来添加计数；
- Done()用来在操作结束时调用，使计数减一；
-  Wait()用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回。

## Go中为什么内存泄漏

如果一个程序持续不断地产生新的 goroutine，且不结束已经创建的 goroutine 并复用这部分内存，就会造成内存泄漏的现象

解决：

Go自带的工具pprof或者使用Gops去检测诊断当前在系统上运行的Go进程的占用的资源


## Go中rune类型


uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。


rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。


## GO的空结构

- 不占据任何内存空间
- 作用
  - map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用
  - 不需要发送任何的数据的channel ，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度


## defer

- 延迟函数的参数在defer语句出现时就已经确定
- 延迟函数执行按 「先进后出」 顺序执行，即先出现的 defer 最后执行
- 延迟函数可能操作主函数的具名返回值

## select

GO 语言中用来提供 IO 复用的机制，它可以检测多个 chan 是否 ready（可读/可写）

- select 语句中除 default 外，每个 case 操作一个channel，要么读要么写
- select语句中除 default 外，各 case 执行顺序是随机的
- select 语句中如果没有 default 语句，则会阻塞等待任一 case
- select 语句中读操作要判断是否成功读取，关闭的 channel 也可以读取


## Go中的分布式锁

多个进程，操作同一份资源，此时需要分布式锁

要解决的问题：

1. 对共享资源操作时候，首先需要加锁，在加锁时候，抢到锁的进程可以直接返回，进而操作共享资源，而没有抢到锁的进程需要等待锁的释放，对于同一个锁，同一时刻只能有一个进程来持有
2. 假如抢到锁的进程突然宕机，需要能够有释放锁的机制，避免后面的进程一直阻塞导致死锁。提供锁的组件也应该具备高可用性，在某个节点宕机后能够继续提供服务
3. 对资源的操作结束之后，需要及时释放锁，但是不能释放其他进程的锁，后面没有抢到锁的进程可以获得锁。如果抢锁的进程过多，可能会导致惊群效应，提供锁的组件应在一定程度上避免该现象



