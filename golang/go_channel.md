# GoChannel

### chan的内部存储
1. 环形队列，存储数据
2. 记录发送数据位置
3. 记录接收数据位置
4. 锁，实现Goroutine safe

创建chan时，**默认分在堆上**，make返回的只是一个指向该对象指针


### 调度

使用 sendq 和 recvq来暂存由于发送或接收而被阻塞的goroutine。

send/recv的时候都会判断recvq/sendq是否有goroutine正在等待，有则优先处理。


### 发送、接收

发送过程：
- 先判断是否有等待接收数据的groutine，如果有，直接将数据发给Groutine，唤醒groutine，就不放入队列中了。
- 队列如果满了，那就只能放到队列中等待，直到有数据被取走才能发送
  - 省去了两次内存拷贝和加锁的开销

接收过程：
- 从channel读取数据时，不是直接去环形队列中取数据，而是先判断是否有等待发送数据的groutine。如果有，直接将groutine出队列，取出数据返回，并唤醒groutine。如果没有等待发送数据的groutine，再从环形队列中取数据

### CSP模型
CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通过共享内存来通信。用于描述两个独立的并发实体通过共享的通讯 channel (管道)进行通信的并发模型

### 从已关闭的channel发送/读取数据，结果如何
- 给一个已经关闭的 channel 发送数据，引起 panic
- 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值

### 无缓冲的 channel 和 有缓冲的 channel 的区别？
- 对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。

- 对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。



### 协程泄漏
协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：
- 缺少接收器，导致发送阻塞
- 缺少发送器，导致接收阻塞
- 死锁(dead lock)
- 无限循环(infinite loops)
  - 为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏