# goroutine —— 协程

## 面试题

### 进程、线程和协程的不同？

分析：这种很明显的是一种逐步演化的路径。也就是`进程-线程-协程`总体而言可以看做是一种演化路线。

审视这个演化，就会发现它是朝着更轻量的方向演进的。于是结合需求和计算机的发展，就会发现：业务越来越复杂，计算机越来越强大，但是我们需要的确是越来越细粒度的资源分配。

进程演进到线程，共享了内存，但是线程可以被CPU单独调度；线程到协程，内存使用量更少了，多个协程绑定到一个线程，相当于大家平分了这个线程的 CPU。

以上这一段吹牛，如果面试记得，可以跟面试官聊。不记得就算了。

**答案**：（首先是标准答案）
1. 进程是资源分配的最小单位，而线程是 CPU 调度的单位，一个进程可以有多个线程。因为同一个进程内的线程共享了堆内存，所以在经常会引起并发编程问题；
2. 协程比线程更轻量级。线程的创建和销毁、调度还需要陷入到内核中，而协程可以认为完全是依赖于用户空间创建、销毁和调度的。同时协程相比线程，占据的资源更加小。

（其次，开始引申）目前来说，很多语言都开始尝试支持协程，主要是因为现在的很多业务都是短平快，或者是 IO 密集的，相比之下，线程也过于重了。

最有名的就是`goroutine`（实际上也不是最有名吧，不过都面试 go 了，就说最有名了），此外还有`kotlin`协程，`python`的协程。

### 类似问题
- 为什么要引入协程？看后面**为什么引入协程**，其实这两个问题基本上一样；


### 为什么要引入协程？

分析：`goroutine` 的引入，本质上还是为了规避一个问题：我又想有并发，但是我又不想陷入到内核里面去。于是就有了这个 `goroutine` 的东西。

该面试题的核心，就是协程“轻量”。这种轻量体现在两方面：
1. 所需要的资源更少
2. 创建销毁和调度更轻量，并不需要陷入内核



答案：因为我们需要一个更轻量的东西来取代线程。（开始聊自己理解的起源）当前绝大多数系统处理的任务都是非常短平快的，或者是 IO 密集这种频繁触发上下文切换的任务。这导致我们如果使用线程，就不得不面临线程频繁切换，陷入内核的问题——这是一个极大的开销。

因此我们需要一个比线程更加轻量的东西。这个东西要具备两个特征：
1. 占有的资源小——我们都是小任务，不需要那么多资源；
2. 创建销毁和调度消耗少——小任务，还时常阻塞，所以调度一定要快要轻；

结合在一起就是`goroutine`了。

#### 类似问题
- 为什么有了线程池还是要有`goroutine`：线程池只是减轻了创建和销毁的开销，但是线程本身还是占有很多资源，上下文调度依然很重

### 怎么避免`goroutine`泄露？

分析：如果你不知道`goroutine`什么时候会结束，就不要使用`goroutine`。这是核心原则。讲完这个原则之后，可以讲一些如何做到“知道goroutine”何时结束。


然后刷两点可以回答”如何发现`goroutine`泄露“。

答案：避免`goroutine`泄露的核心原则是"Never start a goroutine without knowning when it will stop"（用英文会显得你比较专业，记不住可以替换为对应的中文）。

归根结底，就是要有办法控制住结束掉自己开启的`goroutine`。大体上有两类做法：
1. 超时控制，主要利用`context.Timeout`的特性；
2. 主动发信号给`goroutine`关闭。一般是要利用到`channel`的特性；

两种做法基本都要配合`select`特性来。要么是业务正常结束，退出`goroutine`，要么是超时，或者收到关闭信号，异常退出。

（开始讨论如何发现`goroutine`泄露）如果`goroutine`都不是自己开启的，那肯定是没得办法了。只能通过`runtime.NumGoroutine()`方法监控`goroutine`的数量来判断有没有泄露。如果`goroutine`一直在上涨，而且数量也很多，说明泄露很严重。而如果只是轻微泄露，比如说一万个`goroutine`里面泄露了十个，是很难看出来的。

（后面可以进一步引申，跳到**`goroutine`泄露的典型场景**）
（这个问题也可以针对`goroutine`泄露的典型场景来回答，比如说小心使用`channel`，正确使用`mutex`，防止业务一直阻塞等，不过略等于啥也没说）

#### 类似问题
- 如何发现`goroutine`泄露了

### `goroutine`泄露的典型场景

分析：这个问题答案来自煎鱼大佬的文章[跟读者聊 Goroutine 泄露的 N 种方法，真刺激！](https://blog.csdn.net/EDDYCJY/article/details/115535237)

PS：煎鱼大佬的文章都很浅显易懂，即便是难题也能说得很容易理解，大家可以多读读，他有一个公众号《脑子进煎鱼了》，可以关注。

记住，至少背下来里面的一个例子，防着面试官让你手写一个`goroutine`泄露的例子。

然后面试官让你看一段代码，如果有锁，就要怀疑死锁；如果有`channel`就要怀疑`goroutine`泄露；

其实`channel`的代码坑极多，在`channel`里面进一步讨论。

答：有：
- `channel`发送不接收
- `channel`接收不发送
- `nil channel`
- 慢等待
- 互斥锁忘记解锁
- 同步锁使用不当

（同样聊排查作为亮点）排查主要用`runtime.NumGoroutine`或者`pprof`工具。`pprof`会返回所有带有堆栈跟踪的`goroutine`列表。

#### 类似问题
- 可以写一个 `goroutine`泄露的例子吗？
- 或者面试官给你一段代码，让你看有什么问题

## 单核CPU，开两个Goroutine，其中一个死循环，会如何？

Goroutine 里跑着死循环，也就是时时刻刻在运行着 “业务逻辑”。这块需要与单核 CPU 关联起来，考虑是否会一直阻塞住，把整个 Go 进程运行给 hang 住了？

在不同的 Go 语言版本中，结果可能会是不一样的。

1.14版本之前，没有输出。

没有涉及执行权变更的行为，子协程一直循环中，此时主协程无法被调度，整个程序阻塞在子协程中

1.14版本后，有输出

引入基于信号的抢占式调度，能够处理以下情况
- 抢占阻塞在系统调用上的 P
- 抢占运行时间过长的 G

一旦检测到以上场景之一，发信号给M，M收到信号后休眠当前阻塞的Goroutine，调用绑定信号方法，重新调度

## Reference
[跟读者聊 Goroutine 泄露的 N 种方法，真刺激！](https://blog.csdn.net/EDDYCJY/article/details/115535237)
