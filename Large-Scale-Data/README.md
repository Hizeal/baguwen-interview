# 海量数据处理

什么是海量？
- 超大量的数据，分为两种情况
  - 空间：无法一次性装入内存
  - 时间：较短时间内无法迅速解决


解决方法：
1. 分而治之：hash映射 + hash统计 + 排序（堆/快速/归并排序）
2. 多层划分
3. Bitmap


分别介绍方法及对应的问题：

## 分治法

**问题关键词：求最多、前K、文件很大、内存受限**

### 通解
1. Hash映射：利用哈希函数均匀分布的特点，对数据进行哈希计算，然后对数据进行 %num 取余，这样数据就被映射到了 num 个区间（桶）内（取模映射）。 即：把大文件化成(取模映射)小文件，大而化小，各个击破，分而治之，逐个解决。
2. Hash_map进行统计：转换成 num 个小文件（桶）后，可以采用常规的哈希表 hash_map( id, value ) 来统计每个桶中的最大次数；其中每个桶的内存大小是： 所给内存 / num ；
3. 快速排序/堆排序/归并排序：统计完成后用相应的排序算法就可以得到你所需要的数据，然后就可能代码题让你写快排。

例：一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析

答：
- 如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词
- 通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是`O(n*le)`（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是`O(n*lg10)`


## 多层划分

**问题关键词：第N大的数、中位数、不重复或重复的数字**

原理分析：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(n*lg10)

例1：5亿个数据类型为 int 的数据，请求出他们的中位数。

答：

1. 讲 int 划分为 2^16 个区域（因为 int 的数据范围是 [ - 2^15~2^15-1 ] ），第一次扫描，我们遍历5亿个数据，统计落到每个区域里的个数;
2. 根据统计到的个数，就可以知道中位数落到了哪个区域，同时这个区域里的第几个数是中位数；
3. 第二次扫描，我们统计落在那个区域里的数据就可以啦；
实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了

### Bitmap

**问题关键词：快速判断海量数据是否存在所求数据**

例1：服务器收集了 40亿个不重复并且没有排过序的无符号的int整数， 要求使用的内存大小不超过2G；给出一个整数，问如果快速地判断这个整数是否在文件40亿个数据当中？

答：
- 申请一个int数组长度为 int tmp[1+N/32]；其中N代表要进行查找的总数
- tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表:
  - tmp[0]:可表示0~31
  - tmp[1]:可表示32~63
  - tmp[2]可表示64~95
- 如何判断int数字放在哪一个tmp数组中：将数字直接除以32取整数部分(x/32)，例如：整数8除以32取整等于0，那么8就在tmp[0]上；
- 如何确定数字放在32个位中的哪个位：将数字mod32(x%32)。上例中我们如何确定8在tmp[0]中的32个位中的哪个位，这种情况直接mod上32就ok，又如整数8，在tmp[0]中的第8 mod上32等于8，那么整数8就在tmp[0]中的第八个bit位（从右边数起
