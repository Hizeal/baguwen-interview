# 分布式事务是分布式系统中实现事务，多个本地事务组成

由数据库的事务问题，引申至分布式事务。

## 2PC



2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段


1. 准备阶段协调者会给各参与者发送准备命令，除了提交事务之外啥事都做完了。
   1. 若所有参与者都返回准备成功，则发送提交事务命令
   2. 若第一阶段有一个参与者返回失败，则协调者向所有参与者发送回滚事务请求，分布式事务执行失败
2. 同步等待所有资源的响应之后就进入第二阶段即提交阶段（注意提交阶段不一定是提交事务，也可能是回滚事务
   1. 第二阶段执行的是回滚事务操作，那么答案是不断重试，直到所有参与者都回滚了
   2. 第二阶段执行的是提交事务操作，那么答案也是不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功


实质是同步阻塞协议


## 3PC

相比于 2PC 它在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态

分为三阶段：**准备阶段、预提交阶段和提交阶段**，

1. 准备阶段：先去询问此时的参与者是否有条件接这个事务，**因此不会一来就干活**直接锁资源，使得在某些资源不可用的情况下所有参与者都阻塞着
2. 预提交阶段： 与2PC 的准备阶段一样，除了事务的提交该做的都做了。起到了一个统一状态的作用
3. 提交阶段

**超时机制**：

2PC 是同步阻塞的，我们已经分析了协调者挂在了提交请求还未发出去的时候是最伤的，所有参与者都已经锁定资源并且阻塞等待着

如果是等待提交命令超时，那么参与者就会提交事务了，因为都到了这一阶段了大概率是提交的，如果是等待预提交命令超时，那该干啥就干啥了，反正本来啥也没干

超时机制也会带来数据不一致的问题，比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是有可能执行的是回滚操作，这样一来数据就不一致了


## TCC

业务层面的分布式事务,可以跨数据库、跨不同的业务系统来实现事务

TCC 指的是Try - Confirm - Cancel。

- Try 指的是预留，即资源的预留和锁定，注意是预留。
- Confirm 指的是确认操作，这一步其实就是真正的执行了。
- Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。


## 本地消息表

利用了**各系统本地的事务**来实现分布式事务

有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 将业务的执行和将消息放入消息表中的操作放在同一个事务中，这样就能保证消息放入本地表中业务肯定是执行成功的

紧接去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。

如果调用失败也没事，会有后台任务定时去读取本地消息表，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态

本地消息表其实实现的是**最终一致性**，**容忍了数据暂时不一致**的情况